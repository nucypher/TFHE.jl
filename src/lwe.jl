#=
lwe-functions.h
lwekey.h
lwekeyswitch.h
lweparams.h
lwesamples.h
autogenerated.cpp
lwe-functions.cpp
lwe-keyswitch-functins.cpp
lwekey.cpp
lwekeyswitch.cpp
lweparams.cpp
lwesamples.cpp
=#


struct LweParams
    n :: Int32
    alpha_min :: Float64
    alpha_max :: Float64
end


struct LweKey
   params :: LweParams
   key :: Array{Int32, 1}

   LweKey(params::LweParams) = new(params, Array{Int32, 1}(params.n))
end


mutable struct LweSample
    a :: Array{Torus32, 1} # the n coefs of the mask
    b :: Torus32
    current_variance :: Float64 # average noise of the sample

    LweSample(params::LweParams) = new(Array{Torus32, 1}(params.n), 0, 0.)
end



#=
 * This function encrypts message by using key, with stdev alpha
 * The Lwe sample for the result must be allocated and initialized
 * (this means that the parameters are already in the result)
=#
function lweSymEncrypt(result::LweSample, message::Torus32, alpha::Float64, key::LweKey)
    n = key.params.n

    result.b = gaussian32(message, alpha)
    for i in 0:(n-1)
        result.a[i+1] = uniformTorus32_distrib(generator)
        result.b += result.a[i+1] * key.key[i+1]
    end
    result.current_variance = alpha * alpha
end



# This function encrypts a message by using key and a given noise value
function lweSymEncryptWithExternalNoise(
        result::LweSample, message::Torus32, noise::Float64, alpha::Float64, key::LweKey)

    n = key.params.n

    result.b = message + dtot32(noise)

    for i in 0:(n-1)
        result.a[i+1] = uniformTorus32_distrib(generator)
        result.b += result.a[i+1] * key.key[i+1]
    end
    result.current_variance = alpha * alpha
end


# This function computes the phase of sample by using key : phi = b - a.s
function lwePhase(sample::LweSample, key::LweKey)
    n = key.params.n
    axs::Torus32 = 0
    a = sample.a
    k = key.key

    for i in 0:(n-1)
       axs += a[i+1] * k[i+1]
    end
    sample.b - axs
end


# Arithmetic operations on Lwe samples


# result = sample
function lweCopy(result::LweSample, sample::LweSample, params::LweParams)
    n = params.n

    for i in 0:(n-1)
        result.a[i+1] = sample.a[i+1]
    end
    result.b = sample.b
    result.current_variance = sample.current_variance
end


# result = -sample
function lweNegate(result::LweSample, sample::LweSample, params::LweParams)
    n = params.n

    for i in 0:(n-1)
        result.a[i+1] = -sample.a[i+1]
    end
    result.b = -sample.b
    result.current_variance = sample.current_variance
end


# result = (0,mu)
function lweNoiselessTrivial(result::LweSample, mu::Torus32, params::LweParams)
    n = params.n

    for i in 0:(n-1)
        result.a[i+1] = 0
    end
    result.b = mu
    result.current_variance = 0.
end

# result = result + sample
function lweAddTo(result::LweSample, sample::LweSample, params::LweParams)
    n = params.n

    for i in 0:(n-1)
        result.a[i+1] += sample.a[i+1]
    end
    result.b += sample.b
    result.current_variance += sample.current_variance
end


# result = result - sample
function lweSubTo(result::LweSample, sample::LweSample, params::LweParams)
    n = params.n
    sa = sample.a
    ra = result.a

    for i in 0:(n-1)
        ra[i+1] -= sa[i+1]
    end

    result.b -= sample.b
    result.current_variance += sample.current_variance
end

# result = result + p.sample
function lweAddMulTo(result::LweSample, p::Int32, sample::LweSample, params::LweParams)
    n = params.n

    for i in 0:(n-1)
        result.a[i+1] += p*sample.a[i+1]
    end
    result.b += p*sample.b
    result.current_variance += (p*p)*sample.current_variance
end

# result = result - p.sample
function lweSubMulTo(result::LweSample, p::Int32, sample::LweSample, params::LweParams)
    n = params.n

    for i in 0:(n-1)
        result.a[i+1] -= p*sample.a[i+1]
    end
    result.b -= p*sample.b
    result.current_variance += (p*p)*sample.current_variance
end


function lweKeyGen(result::LweKey)
    n = result.params.n
    for i in 0:(n-1)
        result.key[i+1] = rand(generator, 0:1)
    end
end



struct LweKeySwitchKey
    n :: Int32 # length of the input key: s'
    t :: Int32 # decomposition length
    basebit :: Int32 # log_2(base)
    base :: Int32 # decomposition base: a power of 2
    out_params :: LweParams # params of the output key s
    # these don't seem to be used anywhere
    #ks0_raw :: Array{LweSample, 1} # tableau qui contient tout les Lwe samples de taille nlbase
    #ks1_raw :: Array{LweSample, 2} # de taille nl  pointe vers un tableau ks0_raw dont les cases sont espaceés de base positions
    ks :: Array{LweSample, 3} # the keyswitch elements: a n.l.base matrix
    # de taille n pointe vers ks1 un tableau dont les cases sont espaceés de ell positions

    function LweKeySwitchKey(
            n::Int32, t::Int32, basebit::Int32, out_params::LweParams)
        base::Int32 = 1 << basebit
        ks0_raw = [LweSample(out_params) for i in 1:(n * t * base)]
        new(
            n, t, basebit, base, out_params,
            #ks0_raw,
            #reshape(ks0_raw, Int64(n), Int64(t * base)),
            reshape(ks0_raw, Int64(base), Int64(t), Int64(n)))
    end
end


#=
 * translates the message of the result sample by -sum(a[i].s[i]) where s is the secret
 * embedded in ks.
 * @param result the LWE sample to translate by -sum(ai.si).
 * @param ks The (n x t x base) key switching key
 *        ks[i][j][k] encodes k.s[i]/base^(j+1)
 * @param params The common LWE parameters of ks and result
 * @param ai The input torus array
 * @param n The size of the input key
 * @param t The precision of the keyswitch (technically, 1/2.base^t)
 * @param basebit Log_2 of base
=#
function lweKeySwitchTranslate_fromArray(result::LweSample,
        ks::Array{LweSample, 3}, params::LweParams,
        ai::Array{Torus32, 1},
        n::Int32, t::Int32, basebit::Int32)

    base::Int32 = 1 << basebit # base=2 in [CGGI16]
    prec_offset::Int32 = 1 << (32 - (1 + basebit * t)) # precision
    mask::Int32 = base - 1

    for i in 0:(n-1)
        aibar::UInt32 = unsigned(ai[i+1] + prec_offset)
        for j in 0:(t-1)
            aij::UInt32 = (aibar >> (32 - (j + 1) * basebit)) & mask
            if aij != 0
                lweSubTo(result, ks[aij+1,j+1,i+1], params)
            end
        end
    end
end


#=
Create the key switching key: normalize the error in the beginning
 * chose a random vector of gaussian noises (same size as ks)
 * recenter the noises
 * generate the ks by creating noiseless encryprions and then add the noise
=#
function lweCreateKeySwitchKey(result::LweKeySwitchKey, in_key::LweKey, out_key::LweKey)
    n = result.n
    t = result.t
    basebit = result.basebit
    base::Int32 = 1 << basebit
    alpha::Float64 = out_key.params.alpha_min
    sizeks::Int32 = n * t * (base - 1)
    #const int32_t n_out = out_key.params.n;

    err::Float64 = 0

    # chose a random vector of gaussian noises
    noise = Array{Float64, 1}(sizeks)
    for i in 0:(sizeks-1)
        noise[i+1] = randn(generator) * alpha
        err += noise[i+1]
    end
    # recenter the noises
    err = err / sizeks
    for i in 0:(sizeks-1)
        noise[i+1] -= err
    end

    # generate the ks
    index :: Int32 = 0
    for i in 0:(n-1)
        for j in 0:(t-1)

            # term h=0 as trivial encryption of 0 (it will not be used in the KeySwitching)
            lweNoiselessTrivial(result.ks[0+1,j+1,i+1], Torus32(0), out_key.params)
            #lweSymEncrypt(&result.ks[i][j][0],0,alpha,out_key);
            for h in 1:(base-1) # pas le terme en 0
                #=
                // noiseless encryption
                result.ks[i][j][h].b = (in_key.key[i]*h)*(1<<(32-(j+1)*basebit));
                for (int32_t p = 0; p < n_out; ++p) {
                    result.ks[i][j][h].a[p] = uniformTorus32_distrib(generator);
                    result.ks[i][j][h].b += result.ks[i][j][h].a[p] * out_key.key[p];
                }
                // add the noise
                result.ks[i][j][h].b += dtot32(noise[index]);
                =#
                mess::Torus32 = (in_key.key[i+1] * Int32(h)) * Int32(1 << (32 - (j + 1) * basebit))
                lweSymEncryptWithExternalNoise(result.ks[h+1,j+1,i+1], mess, noise[index+1], alpha, out_key)
                index += 1
            end
        end
    end
end


#sample=(a',b')
function lweKeySwitch(result::LweSample, ks::LweKeySwitchKey, sample::LweSample)
    params = ks.out_params
    n = ks.n
    basebit = ks.basebit
    t = ks.t

    lweNoiselessTrivial(result, sample.b, params)
    lweKeySwitchTranslate_fromArray(result, ks.ks, params, sample.a, n, t, basebit)
end
